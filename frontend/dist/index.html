<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>GroundStation 26</title>

    <link rel="icon" href="/favicon"/>

    <!-- Leaflet (served locally from the backend, works offline) -->
    <link
            rel="stylesheet"
            href="/vendor/leaflet/leaflet.css"
    />
    <script
            src="/vendor/leaflet/leaflet.js"
    ></script>

    <!-- Global dark mode styles -->
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: #020617; /* near-black navy */
            color: #e5e7eb; /* light gray text */
            font-family: system-ui, -apple-system, BlinkMacSystemFont,
            'Segoe UI', Roboto, sans-serif;
        }

        #root {
            height: 100%;
            width: 100%;
        }

        #ground-map {
            background-color: #000;
        }

        .emoji-marker {
            font-size: 24px;
            line-height: 32px;
            text-align: center;
            display: inline-block;
        }

        /* Optional: make the user marker look more like a heading indicator */
        .emoji-marker.user-marker {
            transition: transform 0.1s linear;
        }


    </style>

    <!-- JS helpers for the map, called from Rust via wasm_bindgen -->
    <script>
        let groundMap = null;
        let rocketMarker = null;
        let userMarker = null;

        // NEW: remember last-known positions across tab switches
        let lastRocketLatLng = null;
        let lastUserLatLng = null;
        let lastMapView = null;

        // you currently have tiles for z = 0..8
        const MIN_ZOOM = 0;
        const MAX_NATIVE_ZOOM = 12;
        // Must match the Rust NA_BOUNDS used in build.rs:
        // const NA_BOUNDS: (f64, f64, f64, f64) = (-170.0, 5.0, -50.0, 83.0);
        const NA_BOUNDS = {
            lonMin: -170.0,
            latMin: 5.0,
            lonMax: -50.0,
            latMax: 83.0,
        };

        // ---- lon/lat -> tile index, same logic as Rust build.rs ----
        function lonLatToTile(lonDeg, latDeg, zoom) {
            const latRad = (latDeg * Math.PI) / 180.0;
            const n = Math.pow(2, zoom);

            let x = ((lonDeg + 180.0) / 360.0) * n;
            let y =
                (1.0 - Math.log(Math.tan(latRad) + 1.0 / Math.cos(latRad)) / Math.PI) /
                2.0 *
                n;

            const maxIdx = n - 1.0;
            x = Math.max(0.0, Math.min(x, maxIdx));
            y = Math.max(0.0, Math.min(y, maxIdx));

            return {
                x: Math.floor(x),
                y: Math.floor(y),
            };
        }


        function rememberMapView() {
            if (!groundMap) return;
            const center = groundMap.getCenter();
            const zoom = groundMap.getZoom();
            lastMapView = {
                lat: center.lat,
                lon: center.lng,
                zoom,
            };
        }

        // Precompute tile index ranges (xMin/xMax/yMin/yMax) for each zoom
        function buildNaTileRanges() {
            const ranges = {};
            for (let z = MIN_ZOOM; z <= MAX_NATIVE_ZOOM; z++) {
                const a = lonLatToTile(NA_BOUNDS.lonMin, NA_BOUNDS.latMin, z);
                const b = lonLatToTile(NA_BOUNDS.lonMax, NA_BOUNDS.latMax, z);

                ranges[z] = {
                    xMin: Math.min(a.x, b.x),
                    xMax: Math.max(a.x, b.x),
                    yMin: Math.min(a.y, b.y),
                    yMax: Math.max(a.y, b.y),
                };
            }
            return ranges;
        }

        // Custom tile layer:
        // - If coords are outside NA_TILE_RANGES for that zoom, return a black DIV (no network).
        // - Otherwise, load the tile image as normal.
        const NaTileLayer = L.TileLayer;

        function createNaTileLayer(tilesUrl) {
            const naBoundsLatLng = L.latLngBounds(
                [NA_BOUNDS.latMin, NA_BOUNDS.lonMin],
                [NA_BOUNDS.latMax, NA_BOUNDS.lonMax]
            );

            return new NaTileLayer(tilesUrl, {
                bounds: naBoundsLatLng,        // Leaflet won't request tiles outside these lat/lon bounds
                minZoom: MIN_ZOOM,
                maxZoom: MAX_NATIVE_ZOOM,
                maxNativeZoom: MAX_NATIVE_ZOOM,
                noWrap: true,
                attribution: "Local tiles",
            });
        }


        // simple helper to build an emoji-based icon
        function makeEmojiIcon(char, extraClass) {
            return L.divIcon({
                html: `<span class="emoji-marker ${extraClass || ""}">${char}</span>`,
                className: "",
                iconSize: [32, 32],
                iconAnchor: [16, 16],
            });
        }

        const ROCKET_ICON = makeEmojiIcon("ðŸš€", "rocket-marker");
        const USER_ICON = makeEmojiIcon("ðŸ§", "user-marker");

        function centerGroundMapOn(lat, lon) {
            if (!groundMap) return;
            const zoom = groundMap.getZoom() ?? 7;
            groundMap.setView([lat, lon], zoom);
        }


        function getLastUserLatLng() {
            if (!lastUserLatLng) return null;
            return {lat: lastUserLatLng[0], lon: lastUserLatLng[1]};
        }

        // tilesUrl example: "/tiles/{z}/{x}/{y}.jpeg"
        function initGroundMap(tilesUrl, centerLat, centerLon, zoom) {
            const el = document.getElementById("ground-map");
            if (!el) {
                console.warn("initGroundMap: #ground-map element not found");
                return;
            }

            if (groundMap) {
                const currentContainer = groundMap.getContainer();
                if (currentContainer !== el) {
                    groundMap.remove();
                    groundMap = null;
                    rocketMarker = null;
                    userMarker = null;
                    // NOTE: lastRocketLatLng / lastUserLatLng / lastMapView are preserved
                } else {
                    // already initialized on this element â€“ nothing to do
                    return;
                }
            } else {
                initCompass();
            }

            const clampedZoom = Math.max(MIN_ZOOM, Math.min(zoom, MAX_NATIVE_ZOOM));

            // NEW: if we have a remembered view, use that instead of the defaults
            const initialCenter = lastMapView
                ? [lastMapView.lat, lastMapView.lon]
                : [centerLat, centerLon];
            const initialZoom = lastMapView ? lastMapView.zoom : clampedZoom;

            groundMap = L.map(el, {
                center: initialCenter,
                zoom: initialZoom,
                minZoom: MIN_ZOOM,
                maxZoom: MAX_NATIVE_ZOOM,
            });

            createNaTileLayer(tilesUrl).addTo(groundMap);

            // NEW: keep lastMapView updated whenever the user pans/zooms
            groundMap.on("moveend", rememberMapView);
            groundMap.on("zoomend", rememberMapView);
            // capture initial view too
            rememberMapView();

            // existing: restore markers from cached positions
            if (lastRocketLatLng) {
                rocketMarker = L.marker(lastRocketLatLng, {
                    icon: ROCKET_ICON,
                    title: "Rocket",
                }).addTo(groundMap);
            }

            if (lastUserLatLng) {
                userMarker = L.marker(lastUserLatLng, {
                    icon: USER_ICON,
                    title: "You",
                }).addTo(groundMap);
                updateUserMarkerRotation();
            }
        }


        function updateGroundMapMarkers(rLat, rLon, uLat, uLon) {
            if (!groundMap) return;

            const isValid = (x) => typeof x === "number" && !Number.isNaN(x);

            if (isValid(rLat) && isValid(rLon)) {
                const rocketLatLng = [rLat, rLon];
                lastRocketLatLng = rocketLatLng; // <--- remember

                if (!rocketMarker) {
                    rocketMarker = L.marker(rocketLatLng, {
                        icon: ROCKET_ICON,
                        title: "Rocket",
                    }).addTo(groundMap);
                } else {
                    rocketMarker.setLatLng(rocketLatLng);
                }
            }

            if (isValid(uLat) && isValid(uLon)) {
                const userLatLng = [uLat, uLon];
                lastUserLatLng = userLatLng; // <--- remember

                if (!userMarker) {
                    userMarker = L.marker(userLatLng, {
                        icon: USER_ICON,
                        title: "You",
                    }).addTo(groundMap);

                    // ensure initial rotation is applied once element exists
                    updateUserMarkerRotation();
                } else {
                    userMarker.setLatLng(userLatLng);
                }
            }
        }

        let userHeadingDeg = null; // 0..360, where 0 = facing north

        function updateUserMarkerRotation() {
            if (!userMarker || userHeadingDeg == null) return;

            const el = userMarker.getElement();
            if (!el) return;

            const span = el.querySelector(".user-marker");
            if (!span) return;

            // Rotate around center of the emoji
            span.style.transform = `rotate(${userHeadingDeg}deg)`;
            span.style.transformOrigin = "50% 50%";
        }

        // Handle device orientation events
        function handleOrientation(event) {
            // event.alpha is the compass-like heading (0â€“360deg), but device-frame.
            // For many browsers, alpha=0 is facing north; we can treat it as such.
            if (event.alpha == null) return;

            // Convert to compass heading (clockwise from north).
            // Often alpha is already that, but we normalize it anyway.
            const heading = (360 - event.alpha) % 360;

            userHeadingDeg = heading;
            updateUserMarkerRotation();
        }

        // Try to subscribe to orientation events
        function initCompass() {
            if (window.DeviceOrientationEvent) {
                // iOS 13+ requires explicit permission request
                const anyDevOrient = DeviceOrientationEvent;
                if (typeof anyDevOrient.requestPermission === "function") {
                    // You should call this from a user gesture (e.g. button click).
                    anyDevOrient.requestPermission()
                        .then((state) => {
                            if (state === "granted") {
                                window.addEventListener("deviceorientation", handleOrientation);
                            } else {
                                console.warn("DeviceOrientation permission not granted");
                            }
                        })
                        .catch((err) => {
                            console.warn("DeviceOrientation permission error:", err);
                        });
                } else {
                    // Non-iOS browsers (or older iOS) â€“ just attach the listener
                    window.addEventListener("deviceorientation", handleOrientation);
                }
            } else {
                console.warn("DeviceOrientationEvent not supported on this device/browser");
            }
        }

        // Call this once when the page loads (or when map tab mounts)
        initCompass();

    </script>
</head>

<body>
<!-- Leptos mounts to <body> (mount_to_body in lib.rs) -->

<script type="module">
    import init from "./pkg/groundstation_frontend.js";

    // Initialize WASM â†’ mount Leptos
    init().catch(err => {
        console.error("WASM init error:", err);
        document.body.innerText =
            "Failed to load WASM bundle. Check console.";
    });
</script>
</body>
</html>
