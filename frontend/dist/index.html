<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>GroundStation 26</title>

    <link rel="icon" href="/favicon"/>

    <!-- Leaflet (served locally from the backend, works offline) -->
    <link
            rel="stylesheet"
            href="/vendor/leaflet/leaflet.css"
    />
    <script
            src="/vendor/leaflet/leaflet.js"
    ></script>

    <!-- Global dark mode styles -->
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background-color: #020617; /* near-black navy */
            color: #e5e7eb; /* light gray text */
            font-family: system-ui, -apple-system, BlinkMacSystemFont,
            'Segoe UI', Roboto, sans-serif;
        }

        #root {
            height: 100%;
            width: 100%;
        }

        #ground-map {
            background-color: #000;
        }

        .emoji-marker {
            font-size: 24px;
            line-height: 32px;
            text-align: center;
            display: inline-block;
        }

        /* Optional: make the user marker look more like a heading indicator */
        .emoji-marker.user-marker {
            transition: transform 0.1s linear;
        }

        .user-marker-wrapper {
            position: relative;
            width: 32px;
            height: 32px;
        }

        .user-marker-wrapper .user-base {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .user-marker-wrapper .user-heading-indicator {
            position: absolute;
            left: 50%;
            top: 50%;
            transform-origin: 50% 50%;
            transform: translate(-50%, -50%) translateY(-14px);
            transition: transform 0.25s linear; /* was 0.15s */
            font-size: 16px;
        }


    </style>

    <!-- JS helpers for the map, called from Rust via wasm_bindgen -->
    <script>
        let groundMap = null;
        let rocketMarker = null;
        let userMarker = null;

        // NEW: remember last-known positions across tab switches
        let lastRocketLatLng = null;
        let lastUserLatLng = null;
        let lastMapView = null;

        // you currently have tiles for z = 0..8
        const MIN_ZOOM = 0;
        const MAX_NATIVE_ZOOM = 12;
        // Must match the Rust NA_BOUNDS used in build.rs:
        // const NA_BOUNDS: (f64, f64, f64, f64) = (-170.0, 5.0, -50.0, 83.0);
        const NA_BOUNDS = {
            lonMin: -170.0,
            latMin: 5.0,
            lonMax: -50.0,
            latMax: 83.0,
        };

        // Raw + filtered heading (0..360, 0 = North, clockwise)
        let userHeadingDegRaw = null;
        let userHeadingDeg = null;

        // Normalize angle to [0, 360)
        function normalizeAngle(deg) {
            let d = deg % 360;
            if (d < 0) d += 360;
            return d;
        }

        // Smallest signed angle difference from a -> b (in degrees, -180..180)
        function shortestAngleDiff(a, b) {
            let diff = normalizeAngle(b) - normalizeAngle(a);
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            return diff;
        }

        // ---- lon/lat -> tile index, same logic as Rust build.rs ----
        function lonLatToTile(lonDeg, latDeg, zoom) {
            const latRad = (latDeg * Math.PI) / 180.0;
            const n = Math.pow(2, zoom);

            let x = ((lonDeg + 180.0) / 360.0) * n;
            let y =
                (1.0 - Math.log(Math.tan(latRad) + 1.0 / Math.cos(latRad)) / Math.PI) /
                2.0 *
                n;

            const maxIdx = n - 1.0;
            x = Math.max(0.0, Math.min(x, maxIdx));
            y = Math.max(0.0, Math.min(y, maxIdx));

            return {
                x: Math.floor(x),
                y: Math.floor(y),
            };
        }


        function rememberMapView() {
            if (!groundMap) return;
            const center = groundMap.getCenter();
            const zoom = groundMap.getZoom();
            lastMapView = {
                lat: center.lat,
                lon: center.lng,
                zoom,
            };
        }

        // Precompute tile index ranges (xMin/xMax/yMin/yMax) for each zoom
        function buildNaTileRanges() {
            const ranges = {};
            for (let z = MIN_ZOOM; z <= MAX_NATIVE_ZOOM; z++) {
                const a = lonLatToTile(NA_BOUNDS.lonMin, NA_BOUNDS.latMin, z);
                const b = lonLatToTile(NA_BOUNDS.lonMax, NA_BOUNDS.latMax, z);

                ranges[z] = {
                    xMin: Math.min(a.x, b.x),
                    xMax: Math.max(a.x, b.x),
                    yMin: Math.min(a.y, b.y),
                    yMax: Math.max(a.y, b.y),
                };
            }
            return ranges;
        }

        // Custom tile layer:
        // - If coords are outside NA_TILE_RANGES for that zoom, return a black DIV (no network).
        // - Otherwise, load the tile image as normal.
        const NaTileLayer = L.TileLayer;

        function createNaTileLayer(tilesUrl) {
            const naBoundsLatLng = L.latLngBounds(
                [NA_BOUNDS.latMin, NA_BOUNDS.lonMin],
                [NA_BOUNDS.latMax, NA_BOUNDS.lonMax]
            );

            return new NaTileLayer(tilesUrl, {
                bounds: naBoundsLatLng,        // Leaflet won't request tiles outside these lat/lon bounds
                minZoom: MIN_ZOOM,
                maxZoom: MAX_NATIVE_ZOOM,
                maxNativeZoom: MAX_NATIVE_ZOOM,
                noWrap: true,
                attribution: "Local tiles",
            });
        }


        // simple helper to build an emoji-based icon
        function makeEmojiIcon(char, extraClass) {
            return L.divIcon({
                html: `<span class="emoji-marker ${extraClass || ""}">${char}</span>`,
                className: "",
                iconSize: [32, 32],
                iconAnchor: [16, 16],
            });
        }

        const ROCKET_ICON = makeEmojiIcon("üöÄ", "rocket-marker");
        const USER_ICON = L.divIcon({
            html: `
        <div class="user-marker-wrapper">
            <span class="emoji-marker user-base">üßç</span>
            <span class="emoji-marker user-heading-indicator">‚ñ≤</span>
        </div>
    `,
            className: "",
            iconSize: [32, 32],
            iconAnchor: [16, 16],
        });


        function centerGroundMapOn(lat, lon) {
            if (!groundMap) return;
            const zoom = groundMap.getZoom() ?? 7;
            groundMap.setView([lat, lon], zoom);
        }


        function getLastUserLatLng() {
            if (!lastUserLatLng) return null;
            return {lat: lastUserLatLng[0], lon: lastUserLatLng[1]};
        }

        // tilesUrl example: "/tiles/{z}/{x}/{y}.jpeg"
        function initGroundMap(tilesUrl, centerLat, centerLon, zoom) {
            const el = document.getElementById("ground-map");
            if (!el) {
                console.warn("initGroundMap: #ground-map element not found");
                return;
            }

            if (groundMap) {
                const currentContainer = groundMap.getContainer();
                if (currentContainer !== el) {
                    groundMap.remove();
                    groundMap = null;
                    rocketMarker = null;
                    userMarker = null;
                    // NOTE: lastRocketLatLng / lastUserLatLng / lastMapView are preserved
                } else {
                    // already initialized on this element ‚Äì nothing to do
                    return;
                }
            } else {
                initCompass();
            }

            const clampedZoom = Math.max(MIN_ZOOM, Math.min(zoom, MAX_NATIVE_ZOOM));

            // NEW: if we have a remembered view, use that instead of the defaults
            const initialCenter = lastMapView
                ? [lastMapView.lat, lastMapView.lon]
                : [centerLat, centerLon];
            const initialZoom = lastMapView ? lastMapView.zoom : clampedZoom;

            groundMap = L.map(el, {
                center: initialCenter,
                zoom: initialZoom,
                minZoom: MIN_ZOOM,
                maxZoom: MAX_NATIVE_ZOOM,
            });

            createNaTileLayer(tilesUrl).addTo(groundMap);

            // NEW: keep lastMapView updated whenever the user pans/zooms
            groundMap.on("moveend", rememberMapView);
            groundMap.on("zoomend", rememberMapView);
            // capture initial view too
            rememberMapView();

            // existing: restore markers from cached positions
            if (lastRocketLatLng) {
                rocketMarker = L.marker(lastRocketLatLng, {
                    icon: ROCKET_ICON,
                    title: "Rocket",
                }).addTo(groundMap);
            }

            if (lastUserLatLng) {
                userMarker = L.marker(lastUserLatLng, {
                    icon: USER_ICON,
                    title: "You",
                }).addTo(groundMap);
                updateUserMarkerRotation();
            }
        }


        function updateGroundMapMarkers(rLat, rLon, uLat, uLon) {
            if (!groundMap) return;

            const isValid = (x) => typeof x === "number" && !Number.isNaN(x);

            if (isValid(rLat) && isValid(rLon)) {
                const rocketLatLng = [rLat, rLon];
                lastRocketLatLng = rocketLatLng; // <--- remember

                if (!rocketMarker) {
                    rocketMarker = L.marker(rocketLatLng, {
                        icon: ROCKET_ICON,
                        title: "Rocket",
                    }).addTo(groundMap);
                } else {
                    rocketMarker.setLatLng(rocketLatLng);
                }
            }

            if (isValid(uLat) && isValid(uLon)) {
                const userLatLng = [uLat, uLon];
                lastUserLatLng = userLatLng; // <--- remember

                if (!userMarker) {
                    userMarker = L.marker(userLatLng, {
                        icon: USER_ICON,
                        title: "You",
                    }).addTo(groundMap);

                    // ensure initial rotation is applied once element exists
                    updateUserMarkerRotation();
                } else {
                    userMarker.setLatLng(userLatLng);
                }
            }
        }


        function updateUserMarkerRotation() {
            if (!userMarker || userHeadingDeg == null) return;

            const el = userMarker.getElement();
            if (!el) return;

            const indicator = el.querySelector(".user-heading-indicator");
            if (!indicator) return;

            const radius = 14; // distance in px from center
            indicator.style.transform =
                `translate(-50%, -50%) rotate(${userHeadingDeg}deg) translateY(-${radius}px)`;
        }


        // Handle device orientation events
        function handleOrientation(event) {
            let heading = null;

            // 1) iOS Safari / WKWebView: use the proper compass heading if available
            if (typeof event.webkitCompassHeading === "number" && !Number.isNaN(event.webkitCompassHeading)) {
                // webkitCompassHeading: 0 = North, 90 = East, clockwise
                heading = normalizeAngle(event.webkitCompassHeading);
            } else if (event.absolute === true && typeof event.alpha === "number") {
                // 2) Absolute orientation: alpha is often compass-like (0 = North, clockwise)
                heading = normalizeAngle(event.alpha);
            } else if (typeof event.alpha === "number") {
                // 3) Fallback: treat alpha as compass and flip if necessary
                // Many examples use (360 - alpha) to convert device-frame to compass-like.
                heading = normalizeAngle(360 - event.alpha);
            }

            if (heading == null) {
                return; // nothing usable
            }

            userHeadingDegRaw = heading;

            // ---- Smoothing & de-jitter ----
            if (userHeadingDeg == null) {
                // First reading: snap directly
                userHeadingDeg = heading;
            } else {
                // Only react if movement exceeds a small threshold (e.g. 2‚Äì3 degrees)
                const diff = shortestAngleDiff(userHeadingDeg, heading);
                const absDiff = Math.abs(diff);

                const MIN_CHANGE = 2;     // ignore sub-2¬∞ noise completely
                const SMOOTHING = 0.15;   // 0..1; smaller = smoother but laggier

                if (absDiff < MIN_CHANGE) {
                    // ignore tiny jitter
                    return;
                }

                // Exponential smoothing along the shortest rotation direction
                const delta = diff * SMOOTHING;
                userHeadingDeg = normalizeAngle(userHeadingDeg + delta);
            }

            updateUserMarkerRotation();
        }


        // Try to subscribe to orientation events
        function initCompass() {
            if (window.DeviceOrientationEvent) {
                // iOS 13+ requires explicit permission request
                const anyDevOrient = DeviceOrientationEvent;
                if (typeof anyDevOrient.requestPermission === "function") {
                    // You should call this from a user gesture (e.g. button click).
                    anyDevOrient.requestPermission()
                        .then((state) => {
                            if (state === "granted") {
                                window.addEventListener("deviceorientation", handleOrientation);
                            } else {
                                console.warn("DeviceOrientation permission not granted");
                            }
                        })
                        .catch((err) => {
                            console.warn("DeviceOrientation permission error:", err);
                        });
                } else {
                    // Non-iOS browsers (or older iOS) ‚Äì just attach the listener
                    window.addEventListener("deviceorientation", handleOrientation);
                }
            } else {
                console.warn("DeviceOrientationEvent not supported on this device/browser");
            }
        }

        // Call this once when the page loads (or when map tab mounts)
        initCompass();

    </script>
</head>

<body>
<!-- Leptos mounts to <body> (mount_to_body in lib.rs) -->

<script type="module">
    import init from "./pkg/groundstation_frontend.js";

    // Initialize WASM ‚Üí mount Leptos
    init().catch(err => {
        console.error("WASM init error:", err);
        document.body.innerText =
            "Failed to load WASM bundle. Check console.";
    });
</script>
</body>
</html>
